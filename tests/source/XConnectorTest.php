<?php
namespace EventConnector;

use \Exceptions\RecursionLimitExceeded;
use \EventConnector\Exceptions\EventConnectorTerminate;

/**
 * Test class for XConnector.
 * Generated by PHPUnit on 2011-12-18 at 18:53:59.
 */
class XConnectorTest                extends \PHPUnit\Framework\TestCase
{

    /**
     * @var XConnector
     */
    protected $object;

    /**
     * Событие
     * @var XEvent
     */
    protected $event;

    /**
     * @var array
     */
    protected $log;


    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp(): void
    {
        $this->object       = new XConnector;
        $this->event        = new XEvent('event', ['test'], $this);
        $this->log          = [];
    }

    /**
     * Tears down the fixture, for example, closes a network connection.
     * This method is called after a test is executed.
     */
    protected function tearDown(): void
    {
    }

    /**
     * Implement testListener_add().
     */
    public function testListener_add_and_raise()
    {
        $this->object->listener_add([$this, 'x_test_listener1']);
        $this->object->listener_add([$this, 'x_test_listener2']);
        $this->object->listener_add([$this, 'x_test_listener0'], ConnectorI::POS_START);
        $this->object->listener_add([$this, 'x_test_listener3'], ConnectorI::POS_END);
        $this->object->listener_add([$this, 'x_test_listener4'], 4);

        // Проверка на добавление обработчика с уже существующим индексом
        $e = false;
        try
        {
            $this->object->listener_add([$this, 'x_test_listener4'], 4);
        }
        catch (\Exception $e)
        {
        }

        $this->assertTrue(($e instanceof \Exception), 'index already exists?');

        // Проверка на добавление самого себя
        $e      = null;

        try
        {
            $this->object->listener_add($this->object);
        }
        catch (\Exception $e)
        {
        }

        $this->assertTrue(($e instanceof \Exception), 'Attempt to add yourself');

        $e      = null;

        try
        {
            $this->object->listener_raise($this->event, 'test_ex_data');
        }
        catch (\Exception $e)
        {
        }

        $this->assertTrue(($e === null), '\Exception occurred');

        // Проверка порядка выполнения обработчиков
        $this->assertTrue((implode('', $this->log) === '01234'));
    }

    public function testListener_del()
    {
        $this->object->listener_add([$this, 'x_test_listener0']);
        $this->object->listener_add([$this, 'x_test_listener1']);
        $this->object->listener_del(ConnectorI::POS_START);

        $this->object->listener_raise($this->event, 'test_ex_data');
        $this->assertTrue((implode('', $this->log) === '1'));

        $this->log = array();
        $this->object->listener_add([$this, 'x_test_listener2'], ConnectorI::POS_START);
        $this->object->listener_del(ConnectorI::POS_END);
        $this->object->listener_raise($this->event, 'test_ex_data');
        $this->assertTrue((implode('', $this->log) === '2'));

        $this->log = array();
        $this->object->listener_add($this);
        $this->object->listener_add($this);
        $this->object->listener_del($this);
        $this->object->listener_raise($this->event, 'test_ex_data');
        $this->assertTrue((implode('', $this->log) === '20'));

        $e          = null;

        // Проверка на некоректное удаление
        try
        {
            /** @noinspection PhpParamsInspection */
            $this->object->listener_del([$this, 'x_test_listener2']);
        }
        catch (\Exception $e)
        {
        }

        $this->assertTrue(($e instanceof \Exception), 'error delete');

    }

    /**
     * Implement test__invoke().
     */
    public function test__invoke()
    {
        $connector = new XConnector();

        $connector->listener_add([$this, 'x_test_listener0']);
        $connector->listener_add([$this, 'x_test_listener1']);

        $this->object->listener_add([$this, 'x_test_listener2']);
        $this->object->listener_add([$this, 'x_test_listener3']);

        $this->object->listener_add($connector, ConnectorI::POS_START);

        $this->object->listener_raise($this->event, 'test_ex_data');

        // Проверка порядка выполнения
        $this->assertTrue((implode('', $this->log) === '0123'));
    }

    public function testEventConnectorTerminate()
    {
        $this->object->listener_add([$this, 'x_test_listener0']);
        $this->object->listener_add([$this, 'x_test_listener_terminate']);
        $this->object->listener_add([$this, 'x_test_listener1']);

        $res = $this->object->listener_raise($this->event, 'test_ex_data');

        // Проверка порядка выполнения
        $this->assertTrue((implode('', $this->log) === '0terminate'));

        $this->assertTrue(is_array($res));

        $this->assertTrue(isset($res['res']));

        $this->assertTrue(($res['res'] === 'res_test'));
    }


    /**
     * Implement testNestingCallException().
     */
    public function testNestingCallException()
    {
        $connector = new XConnector();

        $connector->listener_add([$this, 'x_test_listener0']);
        $connector->listener_add([$this, 'x_test_listener1']);

        $this->object->listener_add([$this, 'x_test_listener2']);
        $this->object->listener_add([$this, 'x_test_listener3']);

        $this->object->listener_add($connector, ConnectorI::POS_START);
        $connector->listener_add($this->object, ConnectorI::POS_START);

        $e      = null;

        try
        {
            $this->object->listener_raise($this->event, 'test_ex_data');
        }
        catch (\Exception $e)
        {
        }

        $this->assertTrue(($e instanceof RecursionLimitExceeded), 'If NestingCallException no catching');
        $this->assertTrue($this->object->nesting_call_count() > 0, '$this->object->nesting_call_count() <= 0');
    }


    public function x_test_listener($index, EventI $event, $data = false)
    {
        $this->assertTrue(($this->event === $event), '$this->event !== $event');

        $this->assertEquals('test_ex_data', $data);

        $this->log[]        = $index;

        return null;
    }

    public function x_test_listener0(EventI $event, $data = false)
    {
        return $this->x_test_listener(0, $event, $data);
    }

    public function x_test_listener1(EventI $event, $data = false)
    {
        return $this->x_test_listener(1, $event, $data);
    }

    public function x_test_listener2(EventI $event, $data = false)
    {
        return $this->x_test_listener(2, $event, $data);
    }

    public function x_test_listener3(EventI $event, $data = false)
    {
        return $this->x_test_listener(3, $event, $data);
    }

    public function x_test_listener4(EventI $event, $data = false)
    {
        return $this->x_test_listener(4, $event, $data);
    }

    public function __invoke()
    {
        return call_user_func_array([$this, 'x_test_listener0'], func_get_args());
    }

    public function x_test_listener_terminate(EventI $event, $data = false)
    {
        $this->log[] = 'terminate';
        throw new EventConnectorTerminate(['message' => 'test', 'res' => 'res_test']);
    }
}